name: Check Registry Updates
on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch:
jobs:
  check-for-updates:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout application repository
        uses: actions/checkout@v4
      # Клонирайте registry хранилището
      - name: Clone registry repository
        run: |
          git clone https://oauth2:${{ secrets.PERSONAL_ACCESS_TOKEN }}@github.com/lvim-tech/clipack-registry.git registry
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.23'
      - name: Install dependencies
        run: go mod download
      - name: Configure Git for registry
        run: |
          cd registry
          git config user.name 'github-actions[bot]'
          git config user.email '41898282+github-actions[bot]@users.noreply.github.com'
          # Конфигуриране на Git с акредитиви
          git config --global credential.helper store
          echo "https://lvim-tech:${{ secrets.PERSONAL_ACCESS_TOKEN }}@github.com" > ~/.git-credentials
          chmod 600 ~/.git-credentials
      # Създайте временен модифициран Go скрипт, който не зависи от променливи на средата
      - name: Create modified check_registry.go
        run: "cat > modified_check_registry.go << 'EOF'\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"os/exec\"\n    \"path/filepath\"\n    \"strings\"\n\n    \"github.com/google/go-github/v41/github\"\n    \"golang.org/x/oauth2\"\n    \"gopkg.in/yaml.v2\"\n    \"io/ioutil\"\n)\n\n// Тук копираме всички структури и функции от оригиналния файл\ntype Index struct {\n    Packages []string `yaml:\"packages\"`\n}\n\ntype Package struct {\n    Name        string `yaml:\"name\"`\n    Version     string `yaml:\"version\"`\n    Commit      string `yaml:\"commit\"`\n    Description string `yaml:\"description\"`\n    Homepage    string `yaml:\"homepage\"`\n    License     string `yaml:\"license\"`\n    Maintainer  string `yaml:\"maintainer\"`\n    UpdatedAt   string `yaml:\"updated_at\"`\n    Tags        []string `yaml:\"tags\"`\n    Install     struct {\n        Source struct {\n            Type string `yaml:\"type\"`\n            URL  string `yaml:\"url\"`\n            Ref  string `yaml:\"ref\"`\n        } `yaml:\"source\"`\n        Steps []string `yaml:\"steps\"`\n        Binaries []string `yaml:\"binaries\"`\n        AdditionalConfig []struct {\n            Filename string `yaml:\"filename\"`\n            Content  string `yaml:\"content\"`\n        } `yaml:\"additional-config\"`\n    } `yaml:\"install\"`\n}\n\nfunc checkForNewVersionAndCommit(client *github.Client, pkg *Package) (string, string, error) {\n    ownerRepo := strings.TrimPrefix(pkg.Homepage, \"https://github.com/\")\n    ownerRepo = strings.TrimSuffix(ownerRepo, \".git\") // премахване на .git\n    parts := strings.Split(ownerRepo, \"/\")\n    if len(parts) != 2 {\n        return pkg.Version, pkg.Commit, fmt.Errorf(\"invalid repository URL: %s\", pkg.Homepage)\n    }\n    owner, repo := parts[0], parts[1]\n\n    // Check for the latest release\n    release, _, err := client.Repositories.GetLatestRelease(context.Background(), owner, repo)\n    if err != nil {\n        // If there is no release, fall back to getting the latest tag\n        tags, _, err := client.Repositories.ListTags(context.Background(), owner, repo, nil)\n        if err != nil || len(tags) == 0 {\n            return pkg.Version, pkg.Commit, fmt.Errorf(\"error getting latest release or tag: %v\", err)\n        }\n        newVersion := tags[0].GetName()\n        // Check for the latest commit\n        commits, _, err := client.Repositories.ListCommits(context.Background(), owner, repo, nil)\n        if err != nil {\n            return pkg.Version, pkg.Commit, fmt.Errorf(\"error getting commits: %v\", err)\n        }\n        newCommit := commits[0].GetSHA()\n        return newVersion, newCommit, nil\n    }\n    newVersion := release.GetTagName()\n\n    // Check for the latest commit\n    commits, _, err := client.Repositories.ListCommits(context.Background(), owner, repo, nil)\n    if err != nil {\n        return pkg.Version, pkg.Commit, fmt.Errorf(\"error getting commits: %v\", err)\n    }\n    newCommit := commits[0].GetSHA()\n\n    return newVersion, newCommit, nil\n}\n\nfunc main() {\n    // ПРОМЯНА: Директно използване на токена от действието\n    token := \"TOKEN_PLACEHOLDER\"\n    if token == \"\" {\n        log.Fatalf(\"Token cannot be empty\")\n    }\n    \n    ctx := context.Background()\n    ts := oauth2.StaticTokenSource(\n        &oauth2.Token{AccessToken: token},\n    )\n    tc := oauth2.NewClient(ctx, ts)\n    client := github.NewClient(tc)\n\n    // Четене на index.yaml\n    indexData, err := ioutil.ReadFile(filepath.Join(\"registry\", \"index.yaml\"))\n    if err != nil {\n        log.Fatalf(\"Error reading index.yaml: %v\", err)\n    }\n\n    var index Index\n    err = yaml.Unmarshal(indexData, &index)\n    if err != nil {\n        log.Fatalf(\"Error unmarshalling index.yaml: %v\", err)\n    }\n\n    updated := false\n\n    for _, file := range index.Packages {\n        filePath := filepath.Join(\"registry\", file)\n        data, err := ioutil.ReadFile(filePath)\n        if err != nil {\n            log.Fatalf(\"Error reading file %s: %v\", filePath, err)\n        }\n\n        var pkg Package\n        err = yaml.Unmarshal(data, &pkg)\n        if err != nil {\n            log.Fatalf(\"Error unmarshalling YAML for file %s: %v\", filePath, err)\n        }\n\n        newVersion, newCommit, err := checkForNewVersionAndCommit(client, &pkg)\n        if err != nil {\n            log.Printf(\"Error checking for new version and commit for %s: %v\", pkg.Name, err)\n            continue\n        }\n\n        if newVersion != pkg.Version || newCommit != pkg.Commit {\n            pkg.Version = newVersion\n            pkg.Commit = newCommit\n            updated = true\n\n            data, err = yaml.Marshal(&pkg)\n            if err != nil {\n                log.Fatalf(\"Error marshalling YAML for file %s: %v\", filePath, err)\n            }\n\n            err = ioutil.WriteFile(filePath, data, 0644)\n            if err != nil {\n                log.Fatalf(\"Error writing file %s: %v\", filePath, err)\n            }\n        }\n    }\n\n    if updated {\n        // Комитване на промените\n        cmd := exec.Command(\"git\", \"add\", \".\")\n        cmd.Dir = \"registry\"\n        err := cmd.Run()\n        if err != nil {\n            log.Fatalf(\"Error adding changes to git: %v\", err)\n        }\n\n        cmd = exec.Command(\"git\", \"commit\", \"-m\", \"Automated registry update\")\n        cmd.Dir = \"registry\"\n        output, err := cmd.CombinedOutput()\n        if err != nil {\n            log.Fatalf(\"Error committing changes to git: %v, output: %s\", err, output)\n        }\n\n        cmd = exec.Command(\"git\", \"push\")\n        cmd.Dir = \"registry\"\n        output, err = cmd.CombinedOutput()\n        if err != nil {\n            log.Fatalf(\"Error pushing changes to git: %v, output: %s\", err, output)\n        }\n    } else {\n        fmt.Println(\"No updates found.\")\n    }\n}\nEOF\n\n# Заместване на токена като стъпка заменяне на литерал\nTOKEN_VALUE=$(echo -n '${{ secrets.PERSONAL_ACCESS_TOKEN }}')\nsed -i \"s/TOKEN_PLACEHOLDER/$TOKEN_VALUE/g\" modified_check_registry.go\n"
      - name: Run modified check registry script
        run: go run modified_check_registry.go
